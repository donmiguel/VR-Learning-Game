/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/// <reference types="node" />
import { ActionEvent, Actor, ActorLike, ActorSet, Asset, AssetContainer, BehaviorType, CollisionEvent, Context, CreateAnimationOptions, MediaCommand, SetAnimationStateOptions, SetMediaStateOptions, TriggerEvent, UserLike, UserSet } from '../..';
import * as Payloads from '../network/payloads';
import * as Protocols from '../../protocols';
import { MediaInstance } from '../runtime/mediaInstance';
/**
 * @hidden
 */
export declare class InternalContext {
    context: Context;
    actorSet: ActorSet;
    userSet: UserSet;
    userGroupMapping: {
        [id: string]: number;
    };
    assetContainers: Set<AssetContainer>;
    protocol: Protocols.Protocol;
    interval: NodeJS.Timer;
    generation: number;
    prevGeneration: number;
    __rpc: any;
    constructor(context: Context);
    Create(options?: {
        actor?: Partial<ActorLike>;
    }): Actor;
    CreateFromLibrary(options: {
        resourceId: string;
        actor?: Partial<ActorLike>;
    }): Actor;
    CreateFromPrefab(options: {
        prefabId: string;
        actor?: Partial<ActorLike>;
    }): Actor;
    private createActorFromPayload;
    CreateFromGltf(container: AssetContainer, options: {
        uri: string;
        colliderType?: 'box' | 'mesh';
        actor?: Partial<ActorLike>;
    }): Actor;
    createAnimation(actorId: string, animationName: string, options: CreateAnimationOptions): void;
    setAnimationState(actorId: string, animationName: string, state: SetAnimationStateOptions): void;
    setMediaState(mediaInstance: MediaInstance, command: MediaCommand, options?: SetMediaStateOptions, mediaAssetId?: string): void;
    animateTo(actorId: string, value: Partial<ActorLike>, duration: number, curve: number[]): void;
    startListening(): Promise<void>;
    start(): void;
    stop(): void;
    incrementGeneration(): void;
    private assetsIterable;
    update(): void;
    private nextUpdatePromise;
    private resolveNextUpdatePromise;
    /** @hidden */
    nextUpdate(): Promise<void>;
    sendDestroyActors(actorIds: string[]): void;
    updateActors(sactors: Partial<ActorLike> | Array<Partial<ActorLike>>): void;
    sendPayload(payload: Payloads.Payload): void;
    receiveRPC(procName: string, channelName: string, args: any[]): void;
    onClose: () => void;
    userJoined(suser: Partial<UserLike>): void;
    userLeft(userId: string): void;
    updateUser(suser: Partial<UserLike>): void;
    performAction(actionEvent: ActionEvent): void;
    collisionEventRaised(collisionEvent: CollisionEvent): void;
    triggerEventRaised(triggerEvent: TriggerEvent): void;
    setAnimationStateEventRaised(actorId: string, animationName: string, state: SetAnimationStateOptions): void;
    localDestroyActors(actorIds: string[]): void;
    localDestroyActor(actor: Actor): void;
    destroyActor(actorId: string): void;
    sendRigidBodyCommand(actorId: string, payload: Payloads.Payload): void;
    setBehavior(actorId: string, newBehaviorType: BehaviorType): void;
    lookupAsset(id: string): Asset;
}
//# sourceMappingURL=context.d.ts.map