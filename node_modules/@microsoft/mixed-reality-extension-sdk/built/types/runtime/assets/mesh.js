"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const __1 = require("..");
const __2 = require("../../..");
const asset_1 = require("../../internal/asset");
/** Represents a mesh on an actor */
class Mesh extends _1.Asset {
    /** @hidden */
    constructor(container, def) {
        super(container, def);
        // tslint:disable:variable-name
        this._internal = new asset_1.InternalAsset(this);
        this._dimensions = new __2.Vector3();
        this._center = new __2.Vector3();
        this._primDef = null;
        if (!def.mesh) {
            throw new Error("Cannot construct mesh from non-mesh definition");
        }
        this.copy(def);
    }
    // tslint:disable:variable-name
    /** @hidden */
    get internal() { return this._internal; }
    /** @inheritdoc */
    get vertexCount() { return this._vertexCount; }
    /** @inheritdoc */
    get triangleCount() { return this._triangleCount; }
    /** @inheritdoc */
    get boundingBoxDimensions() { return this._dimensions; }
    /** @inheritdoc */
    get boundingBoxCenter() { return this._center; }
    /** @inheritdoc */
    get primitiveDefinition() { return this._primDef; }
    /** @inheritdoc */
    get mesh() { return this; }
    copy(from) {
        if (!from) {
            return this;
        }
        // Pause change detection while we copy the values into the actor.
        const wasObserving = this.internal.observing;
        this.internal.observing = false;
        // tslint:disable:curly
        super.copy(from);
        if (from.mesh && from.mesh.vertexCount !== undefined)
            this._vertexCount = from.mesh.vertexCount;
        if (from.mesh && from.mesh.triangleCount !== undefined)
            this._triangleCount = from.mesh.triangleCount;
        if (from.mesh && from.mesh.boundingBoxDimensions)
            this._dimensions.copy(from.mesh.boundingBoxDimensions);
        if (from.mesh && from.mesh.boundingBoxCenter)
            this._center.copy(from.mesh.boundingBoxCenter);
        if (from.mesh && from.mesh.primitiveDefinition)
            this._primDef = from.mesh.primitiveDefinition;
        // tslint:enable:curly
        this.internal.observing = wasObserving;
        return this;
    }
    /** @hidden */
    toJSON() {
        return Object.assign({}, super.toJSON(), { mesh: {
                vertexCount: this.vertexCount,
                triangleCount: this.triangleCount,
                boundingBoxDimensions: this.boundingBoxDimensions,
                boundingBoxCenter: this.boundingBoxCenter,
                primitiveDefinition: this.primitiveDefinition
            } });
    }
    /** @hidden */
    breakReference(ref) {
        if (!(ref instanceof __1.Actor))
            return;
        if (ref.appearance.mesh === this) {
            ref.appearance.mesh = null;
        }
    }
}
exports.Mesh = Mesh;
//# sourceMappingURL=mesh.js.map